Модуларност
===========

У овој лекцији:

- пример разлагања пројекта на модуле,
- шта је тесна, а шта лабава спрегнутост модула,
- које су мане тесне, односно предности лабаве спрегнутости.


У већим софтвреским пројектима посебан изазов представља организовање кôда у мање целине, које често неформално зовемо модулима. Препознавање и издвајање тих мањих целина између осталог омогућава да се оне лакше употребе и у другим пројектима.

У објектно оријентисаном програмирању, класа је природна целина која већ групише одређену функционалност и издваја је од осталог кода. Ипак, релативно је ретко да једна изолована класа сама за себе пружа довољно функционалности и не повезује се са другим класама. Обично је за пружање заокружене услуге потребно неколико класа које међусобно тесно сарађују.

У неким случајевима је врло једноставно да се уочи таква група класа, па се она природно издваја и организује у целину коју лако можемо да укључимо у разне пројекте. Међутим, некад је за уочавање таквих целина потребан "поглед из висине", односно сагледавање шире слике и размишљање на високом нивоу апстракције. Оно што уме да буде тешко при решавању конкретног, сложеног проблема је да умемо "да се измакнемо" и за тренутак престанемо да размишљамо само о том проблему. За разлагање проблема и организацију кода је веома корисно да сагледамо функционалности које решавају неке базичне потпроблеме и које би могле да буду корисне и у другом контексту.

На пример, апликација која кориснику приказује неке податке, могла би поред осталих, да садржи ове модуле:

- модул за комуникацију са сервером: успостављање конекције, прибављање података, пријављивање за праћење каснијих промена у подацима
- модул за израчунавање података који интересују корисника, на основу прибављених података
- модул за приказ података на разне начине (исписом у конзолни прозор, или помоћу разних табела, графикона, дијаграма и сл.)
- модул за графички интерфејс према кориснику: прихватање захтева за новим подацима, за променом приказа, за одјављивање праћења промена...

За сваки од ових модула би релативно једноставно могло да се организује тестирање, независно од осталих модула. То у многоме олакшава развој, јер се неисправности (багови) или евентуалне регресије (назадовање у развоју, губитак функционалности услед грешке), брже и лакше откривају. Наведени модули могу даље да се састоје од још мањих модула, организованих на сличан начин.

Идеју о растављању на модуле ћемо детаљније да илуструјемо на следећем малом примеру, мада овај начин размишљања постаје утолико значајнији што је пројекат већи и сложенији.

Пример - аналитичка геометрија
------------------------------

У задацима из аналитичке геометрије често је потребно да се одреде координате пресека две праве, пресека круга и праве, координате средишта дужи, једначина симетрале дужи, једначина праве нормалне на дату праву која садржи дату тачку итд.

У таквим задацима су очигледно важни појмови тачке и праве, па је корисно да их представимо класама ``Tacka``, односно ``Prava``. Поред ова два основна појма, врло је користан и појам вектора, па ћемо и њега да представимо одговарајућом класом ``Vektor``. Кроз дати пример ће постати очигледно колико су вектори корисни у решавању задатака овог типа.

Група од ове три класе већ представља згодну целину која може да се употреби при решавању многих задатака, па смо зато ове класе издвојили у посебан фајл. Класе дефинисане у фајлу су стављене у један заједнички именски простор, чиме додатно наглашавамо њихову повезаност.

.. activecode:: ag_lib
    :passivecode: true
    :includesrc: src/ag_lib.cs

Овако написан фајл може да се укључи у разне апликације, како конзолне, тако и оне са графичким интерфејсом. Да бисмо довршили пример, ми ћемо овај фајл да укључимо у конзолну апликацију која решава неколико задатака из аналитичке геометрије. 
 
.. activecode:: ag_lib_demo_console
    :passivecode: true
    :includesrc: src/ag_lib_demo_console.cs    
    
На овај начин смо пројекат поделили у два модула, које можемо да назовемо ``AG`` и ``geom_zadaci_con`` по њиховим именским просторима. 

Даљим развојем модула ``AG`` би могло да се очекује да постојећој групи класа додамо још неке, а да постојеће класе добију нове методе. На пример, могли бисмо да додамо класу ``Krug``, која би омогућила једнако удобно решавање шире класе задатака. Са друге стране, на пример, класи ``Prava`` можемо да додамо метод ``ToString`` за исписивање једначине праве, метод ``Parse`` за инстанцирање праве на основу њене једначине записане у неком стандардном облику (дате као стринг), метод за пресек са кругом (који би могао да враћа пар референци на тачке, с тим да референце буду празне ако не постоји пресек) итд. 

Уколико кôд модула ``AG`` постане велики и непрегледан, дати фајл може да се подели на неколико фајлова, од којих би сваки садржао по једну класу. Садржај свих тако насталих фајлова би и даље припадао истом именском простору, тј. сваки фајл би био облика

.. code-block:: csharp

    namespace AG 
    { 
        ... 
    }

док би се кôд који користи ове класе и даље налазио у именском простору ``geom_zadaci_con``, па би било потребно само на почетку фајла да се наведе ``using AG;``. 

Одлука о томе када неки фајл постаје превелики и треба да се подели на мање фајлове је ствар процене и договора тима. Уобичајена величина фајла (чак и у веома великим пројектима) је од стотинак, до пар хиљада линија кода.

Спрегнутост модула
------------------

При разлагању већег пројекта на логичке целине (модуле) посебно треба водити рачуна о такозваној спрегнутости кода (енгл. *code coupling*). 

Како год да разложимо кôд на модуле, неки модули ће да зависе од других. У претходном примеру модул ``geom_zadaci_con`` зависи од модула ``AG``. Међузависност модула може да се представи усмереним графом, где модули представљају чворове, а зависности гране графа. Циљ коме се тежи је да тај граф буде што једноставнији. На пример, кружне зависности модула (циклуси у графу) су веома непожељне, јер то значи да сви модули који чине циклус морају да буду заједно укључени у сваки пројекат. Ово је јасан сигнал да кôд није добро подељен на модуле, јер се узајамно зависни модули понашају као један велики модул. У таквом и сличним случајевима кажемо да у коду постоји тесна спрегнутост (*tight coupling*). Такође није добро да један модул зависи од великог броја других модула. Таква ситуација је обично сигнал да је тај модул превелики, или да је нека класа у њему лоше дизајнирана (има превише функционалности).

Када је пројекат добро подељен на модуле, кôд је лабаво спрегнут (*loose coupling*). У том случају је граф зависности модула ацикличан и обично има релативно мали број грана. У ацикличном графу чворови могу да се групишу у слојеве. Најнижем слоју у графу одговарају модули који не зависе од других модула, и они представљају неку базичну функционалност. Модули тог најнижег слоја су добри кандидати за креирање потпуно независних библиотека. Вишим слојевима одговарају модули који зависе од претходних слојева. 

Број слојева у графу зависности модула не мора да буде велики, могуће је да их буде свега два или три чак и у великим пројектима. Умеће организовања кода у модуле се огледа у једноставности добијеног графа зависности, чак и када он има много чворова.


.. figure:: ../../_images/spregnutost.png
    :width: 600px
    :align: center   
    
    Пример лоше, тесне спрегнуторсти (лево), где сваки модул посредно или непосредно зависи од сваког другог, и добре, лабаве спрегнутости (десно), где постоје слојеви.

Неке од предности лабаво спрегнутих модула у пројекту смо већ истакли - такве модуле је знатно лакше одвојено тестирати, а и поново искористити у другим пројектима, или деловима великог пројекта. Поменућемо још једну корист коју имамо од лабаве спрегнутости, а која није тако очигледна. Током развоја програма честе су мале измене, после којих желимо да испробамо како програм ради. При лабавој спрегнутости, мале измене у коду погађају само мали број (малих) модула, тако да се извршиви фајл веома брзо формира. Када у пројекту постоје веома велики, или тесно спрегнути модули, они често завршавају у истом извршивом фајлу (статички се линкују), па може да се догоди да после измене само једне линије кода линковање траје и по неколико минута.
