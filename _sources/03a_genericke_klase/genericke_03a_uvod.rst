Генеричке класе и методи
========================

У овој лекцији:

- Шта су генеричке класе и генерички методи
- Које су предности генеричких класа
- Како да правимо своје генеричке класе

Шта су генеричке класе
----------------------

Када користимо листу, по начину позивања њених метода 

.. activecode:: lista_je_klasa
    :passivecode: true

    List<int> b = new List<int>();

    ...

    b.Add(x); // a ne List.Add(b, x);
    b.Sort(); // a ne List.Sort(b);
    ...

јасно је да је ``b`` је објекат неке класе, јер има сопствене (нестатичке) методе. Према 
томе, ``List`` јесте класа, мада је другачија од класа које смо до сада научили да пишемо. 
Тип елемената листе очигледно није дефинисан у самој класи, јер имамо могућност да га 
задамо накнадно, тј. тек при декларацији листе. Сличну особину имају и друге класе, нпр:

.. activecode:: bibl_klase_sa_parametrima
    :passivecode: true

    HashSet<string> h = new HashSet<string>();
    Dictionary<string, int> d = new Dictionary<string, int>();
    Stack<double> st = new Stack<double>();
    Queue<Tuple<int, int>> q = new Queue<Tuple<int, int>>();
    ...

.. infonote::

    Класе код којих се један или више типова наводе (у шпицастим заградама) приликом 
    декларисања објеката класе, називају се **генеричке класе**. 

Генеричке класе користе типове података **као параметре**. Захваљујући томе, комплетна 
класа са свим својим методима, својствима итд. се пише само једном, а користи се као 
више различитих класа. На пример, класа ``List`` може да се користи за креирање листе 
целих бројева, листе карактера, листе стрингова...

Најчешћа (мада не и једина) употреба генеричких класа је креирање класа колекције, па 
ћемо се овде бавити само таквим примерима. У именском простору ``System.Collections.Generic``
већ су дефинисане разне најчешће коришћене колекције, а нешто касније ћемо видети како 
можемо да направимо своје, специфичне колекције у облику генеричких класа.


Корист од генеричких класа
--------------------------

Када би се у библиотеци уместо генеричке класе ``List`` налазиле конкретне (негенеричке) 
класе ``IntList``, ``CharList``, ``StringSlist`` и друге, такав приступ би имао две 
велике мане:

- било би потребно да се пише и одржава више кода, у коме постоји много сличности,
- не би биле подржане листе објеката чију класу ми дефинишемо.

Према томе, помоћу генеричких класа **уз мање писања кода добијамо више функционалности**. 

Генеричке класе су један од начина да се оствари важан концепт **поновне искористивости** 
(енгл. *reusability*) једном написаног кода. Други начини да се оствари поновна искористивост 
обухватају наслеђивање класа, о чему ће бити речи у наставку, као и издвајање кода у 
библиотеке.

.. infonote::

    **Пре развоја генеричких класа:**
    
    Некада је функционалност коју доносе генеричке класе -- колекције симулирана у разним 
    програмским језицима тако што су коришћени објекти најопштијег типа `Object`, или неког 
    сличног имена (у раним верзијама језика `C#` коришћена је класа ``ArrayList``, која 
    је одавно превазиђена). Овакав приступ је лошији од генеричких класа из бар два разлога.
    
    - Исправност стварног типа објеката не може да се провери у време компајлирања, него 
      тек у време извршавања. Ово оставља простор за многе грешке при извршавању (багове), 
      који се теже откривају и исправљају него грешке при компајлирању.
    - Провера слагања типова при операцијама над објектима у току извршавања програма 
      чини програм споријим него што би могао да буде (да је провера обављена у време 
      компајлирања).

Генеричке класе које дефинише корисник
--------------------------------------

Ми такође можемо да пишемо генеричке класе. На пример, када у библиотеци .NET не би 
постојала класа ``Stack``, могли бисмо да је напишемо овако:

.. activecode:: stek_t
    :passivecode: true
    :includesrc: src/primeri/gereric_stek.cs

Програм који демонстрира употребу класе ``CustomStack``, исписује

.. code::

    d
    c
    b
    a

Видимо да се писање генеричких класа врло мало разликује од писања конкретних класа. У ствари, 
једина разлика је то што се појављује за сада неодређени (општи, генерички) тип ``T``, али он 
се користи на постпуно исти начин, на који бисмо користили ``int``, ``char``, ``double`` или било 
који други конкретан тип. Ознака ``T`` за општи тип је уобичајена, мада уместо ње може да се 
користи било који идентификатор, који у ту сврху уведемо. 

Генерички методи
----------------

Генерички тип не мора да буде параметар целе класе, могуће је направити појединачне методе 
са генеричким типом као параметром, тј. **генеричке методе**. На пример, ако нам је често 
потребан метод којим две променљиве или два објекта одређеног типа размењују вредности, 
можемо да напишемо генерички метод ``Swap`` на следећи начин.

.. activecode:: generic_swap
    :passivecode: true
    :includesrc: src/primeri/generic_swap.cs
    

Програм исписује

.. code::

    2, 1
    dva, jedan


Резимирајмо: најважније предности генеричких класа и метода у односу на друга решења су:

- **олакшана поновна употреба** кода, без копирања и преправљања,
- **безбедност типова:** (енгл. *type safety*) слагање типова се проверава статички, тј. 
  у веме компајлирања (за разлику од решења у коме се користе општи објекти, 
  компајлер тачно зна који тип података се користи на сваком месту).
- **боље перформансе** у односу на решења са општим објектима, јер се смањује 
  потреба за конверзијом променљивих у објекте (тзв. боксовање), распакивањем из 
  објеката назад у променљиве и провером типа у време извршавања.


.. comment 

        
    .. code::

        public class QueueWNoDup<T> where T : struct
        {
            //...
        }
