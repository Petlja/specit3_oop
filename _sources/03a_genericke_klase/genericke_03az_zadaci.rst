Генеричке класе - задаци
========================

.. questionnote::

    **1. Колекција са курсором**
    
    Написати генеричку класу ``CollectionWihCursor<T>`` описану у овој лекцији, користећи 
    класу ``LinkedList`` као основу за имплементацију. 

**Напомена:** за детаљнији опис класе и демо програм погледати текст лекције.


.. questionnote::

    **2. Ред без дупликата**
    
    Написати генеричку класу ``QueueWNoDup<T>``, која имплементира стек елемената типа ``T``,
    који не прихвата елементе које већ садржи. Јевни метод ``public bool Enqueue(T x)`` треба 
    да врати вредност ``true`` ако је убацивање елемента на стек успело, а ``false`` ако није,
    тј. ако такав елемент већ постоји у реду. 
    
    Поред метода ``Enqueue`` треба још написати јавне методе ``bool Empty()`` и ``T Dequeue()``.
    
    Сложеност свих операција треба да буде :math:`O(1)`.

**Напомена:** у овом задатку, референцирани типови се сматрају једнаким само ако су им исте адресе 
(без обзира на могуће једнак садржај), тј. само ако се ради о истом објекту у меморији. 

.. reveal:: pomoc_za_QueueWNoDup
    :showtitle: Помоћ
    :hidetitle: Сакриј помоћ
    
    **Помоћ**: у имплементацији користити обичан ред (класа ``Queue``) и скуп (класа ``HashSet``).


.. questionnote::

    **3. Стек са максимумом**
    
    Написати генеричку класу ``StackWithMax<T>``, која имплементира стек елемената типа ``T``.
    Поред уобичајених функционалности стека, ова класа треба да има и метод ``GetMax``, 
    која враћа вредност највећег елемента са стека.
    
    Сложеност свих операција треба да буде :math:`O(1)`.

**Напомена:** у овом задатку, приликом дефинисања генеричке класе треба писати

.. activecode:: generic_StackWithMax
    :passivecode: true

    public class StackWithMax<T> where T : IComparable
    {
        //...
    }
    
да би унутар дефиниције класе могао да се користи метод ``CompareTo`` за објекте 
генеричког типа ``T``. Овим је употреба класе ограничена само на типове који имају дефинисан 
метод ``CompareTo``. Ово ограничење је природно, јер да би могло да се одреди који елемент 
стека је највећи, свакако мора да постоји поређење елемената по величини.

.. reveal:: pomoc_za_StackWithMax
    :showtitle: Помоћ
    :hidetitle: Сакриј помоћ
    
    **Помоћ**: у имплементацији користити два обична стека (класа ``Stack``).

 
.. questionnote::

    **4. Фреквенцијски стек**
    
    Написати генеричку класу ``FreqStack<T>``, која имплементира колекцију налик на стандардни стек 
    елемената типа ``T``.

    Класа треба да има следеће јавне методе:
    
    - ``bool Empty()`` - враћа ``true`` ако је колекција празна, иначе враћа ``false``
    - ``void Clear()`` - уклања све елементе из колекције
    - ``void Push(T x)`` - додаје елемент ``x`` у колекцију
    - ``T Pop()`` - уклања из колекције елемент који се најчешће појављује од свих елемената 
      који су тренутно на стеку. Ако је више таквих елемената, уклања се онај који је последњи 
      додат. Нпр. ако редом додавани елементи 1 2 2 1 3, уклања се елемент 1 и садржај колекције 
      је исти као да су додати 1 2 2 3.

.. reveal:: pomoc_za_FreqStack
    :showtitle: Помоћ
    :hidetitle: Сакриј помоћ
    
    **Помоћ**: у имплементацији користити листу стекова (``List<Stack<T>>``) и речник који 
    броји појављивања сваког елемента на стеку (``Dictionary<T, int>``).

 
.. comment

    multiskup (da ima operacije sa skupovima: presek, uniju, razliku)

    mapa sa uvecanjem       // ruzno - mnogo dynamic
    
