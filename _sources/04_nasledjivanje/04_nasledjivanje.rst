Наслеђивање и полиморфизам
==========================

Као један од најважнијих концепата објектно оријентисаног програмирања, наслеђивање је централна 
тема и овог курса. Већ у уводној лекцији, говорећи о парадигмама у програмирању, поменули смо да 
су у оквиру ООП парадигме концепти наслеђивања и са њиме повезаног динамичког полиморфизма 
одговорили на одређене честе потребе програмера. Сада је време да прецизније опишемо те потребе 
и начине на које се оне задовољавају.

Прво ћемо да опишемо проблем надовезивања на постојећу функционалност, на који програмери редовно 
наилазе радећи на већим пројектима. Осврнућемо се и на детаље због којих решења која обично прва 
падају на памет нису довољно добра. Затим ћемо да видимо како **наслеђивање** решава тај проблем 
на задовољство свих заинтересованих страна. 

Други тип проблема је сличан, али се до њега долази обрнутим путем. Често се дешава да планирамо 
неколико сличних класа, код којих се неки методи природно позивају на исти начин, али се различито 
извршавају. При томе поменуте класе могу да имају и неке методе или да садрже неке податке који би 
били потпуно исти у свим тим класама. Један циљ који желимо да остваримо је да избегнемо појављивање 
истог кода на различитим местима, што се, као што смо поменули, удобно решава наслеђивањем. Други 
циљ је да додатно искористимо сличности објеката таквих класа и поједноставимо њихову употребу. 
Примера ради, замислимо да треба да обрадимо већи број објеката који су међусобно врло слични, али 
нису исти. Обрада може да се састоји од позива истоимених метода над тим разнородним, а сличним 
објектима. У таквом случају, било би посебно удобно да разнородне објекте можемо да држимо све у 
једној колекцији и да их све користимо на исти начин, не водећи рачуна о разликама између њих. Краће 
речено, други циљ је да омогућимо (динамички) **полиморфизам**. Згодан начин за постизање динамичког 
полиморфизма је употреба **апстрактних класа** и **интерфејса**. Највећи број примера и задатака до 
краја овог курса је у вези са динамичким полиморфизмом и предностима које он доноси.

На крају ћемо се дотаћи и могућности мењања, односно преправљања наслеђеног понашања, што се остварује 
помоћу **виртуелних** метода. Типична ситуација је да имамо више сличних класа, где један метод за 
већину тих класа треба да ради на исти начин, а нпр. за једну на другачији начин. Тада "већински" начин 
рада можемо да сместимо на једно место и прогласимо за подразумевани, што значи да друге класе могу 
да га наследе и користе без измене, док класе којима то не одговара могу да га преиначе. 

Све поменуте новине су донеле одређене погодности, али и неке проблеме због којих су мање или више 
критиковане. Примедбе се углавном односе на спорије извршавање и могућност погрешне употребе због 
недовољног разумевања коришћених механизама, или самог проблема који се решава. Због тога је важно 
да се добро разумеју предности и мане нових концепата, као и семантика (ефекти, дејство) наредби кроз 
које се ти концепти уводе, како бисмо у конкретним ситуацијама доносили што боље одлуке у погледу 
дизајна софтвера. 


.. comment

    у случајевима када само наслеђивање није довољно за превазилажење проблема. Испоставиће се да 
    концепт наслеђивања доноси могућност проширивања, а концепт виртуелних функција могућност измене 
    функционалности постојеће класе, а при томе и једно и друго без лоших пропратних ефеката. 

    Увођењем апстрактних класа и интерфејса додатно развијамо идеју преправљања полазне верзије класе. 
    Новост у односу на виртуелне функције је у томе што можемо и да инсистирамо да свако ко жели да 
    користи неку класу мора да обезбеди верзију те класе прилагођену себи. Ово је згодно у ситуацијама 
    када не постоји неко понашање полазне касе које би одговарало већини корисника те класе, тј. 
    ниједно понашање није погодно као подразумевано. 

    На крају поглавља сусрећемо се са динамичким полиморфизмом као начином да сродне објекте једнако 
    третирамо, а да се они различито понашају. Конкретније, ако те сродне објекте дохватамо преко 
    референци на базну класу, ми на месту употребе не морамо да знамо којој стварној класи припада који 
    објекат, па чак ни да знамо које све изведене класе уопште постоје и по чему се разликују. Ми само 
    позивамо метод дефинисан (или само декларисан) у базној класи, а сваки објекат позива свој специфичан 
    метод и тиме се понаша различито од осталих објеката. 

