Наслеђивање и полиморфизам
==========================

Као један од најважнијих концепата објектно оријентисаног програмирања, наслеђивање је централна 
тема и овог курса. Већ у уводној лекцији, говорећи о парадигмама у програмирању, поменули смо да 
су у оквиру ООП парадигме концепти наслеђивања и са њиме повезаног динамичког полиморфизма 
одговорили на потребе програмера, које кратко могу да се опишу речима "треба ми то што већ 
постоји, али само мало другачије", а да при томе постојећи кôд не мора ни да се мења, ни да се 
копира. Сада је време да прецизније опишемо те потребе програмера и начине на које се оне 
задовољавају.

Прво ћемо да се упознамо са једном врстом проблема на коју програмери редовно наилазе радећи на 
већим пројектима, са освртом на детаље због којих решења која обично прва падају на памет нису 
довољно добра. Затим ћемо да видимо како **наслеђивање** решава тај проблем на задовољство свих 
заинтересованих страна. На сличан начин ћемо да дођемо и до разлога за увођење виртуелних функција, 
у случајевима када само наслеђивање није довољно за превазилажење проблема. Испоставиће се да 
концепт наслеђивања доноси могућност проширивања, а концепт виртуелних функција могућност измене 
функционалности постојеће класе, а при томе и једно и друго без лоших пропратних ефеката. 

Увођењем апстрактних класа и интерфејса додатно развијамо идеју преправљања полазне верзије класе. 
Новост у односу на виртуелне функције је у томе што можемо и да инсистирамо да свако ко жели да 
користи неку класу мора да обезбеди верзију те класе прилагођену себи. Ово је згодно у ситуацијама 
када не постоји неко понашање полазне касе које би одговарало већини корисника те класе, тј. 
ниједно понашање није погодно као подразумевано. 

На крају поглавља сусрећемо се са динамичким полиморфизмом као начином да сродне објекте једнако 
тертирамо, а да се они различито понашају. Конкретније, ако те сродне објекте дохватамо преко 
референци на базну класу, ми на месту употребе не морамо да знамо којој стварној класи припада који 
објекат, па чак ни да знамо које све изведене класе уопште постоје и по чему се разликују. Ми само 
позивамо метод дефинисан (или само декларисан) у базној класи, а сваки обекат позива свој специфичан 
метод и тиме се понаша различито од осталих објеката. 

Динамички полиморфизам је изузетно удобан начин да се постигне описани ефекат, јер је кôд на месту 
употребе типично врло једноставан, тј. нема сложене логике проверавања типова. Сложеност у случају 
динамичког полиморфизма није на једном месту, већ је разложена и распоређена по класама наследницама.
