Основно о наслеђивању
=====================

У овој лекцији:

- Који проблем решава наслеђивање 
- Како се користи наслеђивање
- Наслеђивање као нова врста односа између класа

Зашто нам је наслеђивање потребно
---------------------------------

Замислимо следећу ситуацију. У оквиру већег пројекта негде већ постоји класа која нам делимично 
одговара, тако да бисмо је радо допунили неким методима који су нама потребни. Са друге стране, 
колеги који је ту класу написао она одговара таква каква је. Њему би нова функционалност само 
повећала и закомпликовала класу и донекле успорила даљи развој. Најгоре од свега, мењање кода те 
класе би донело ризик да се постојећа функционалност поремети, тј. да се унесу багови. Зато се 
он противи мењању те класе. 

Пошто за мењање класе нисмо добили сагласност, следеће што може да нам падне на памет је да 
поменуту класу копирамо и преименујемо, а затим прилагодимо својим потребама. На жалост, ту долази 
до делимичног дуплирања кода, што је лоше из више разлога, као што смо често истицали. Као прво, 
цео програм расте и постаје непрегледнији и тежи за сналажење. Као друго, ако се усвоји пракса 
копирања кода, пре или касније се дешава да исправка или раније планирана измена која је учињена 
на једном месту, не буде пренесена у све копије у које би требало. Због таквог стања кода, може 
да буде потрошено доста времена да се установи да ли неке разлике које су у међуверемену настале 
треба да се елиминишу или не, односно која везија треба да се прилагоди оној другој. Ситуација је 
још компликованија ако уместо две постоји више верзија сличног кода. Све у свему, дугорочно 
гледано, копирање је лоша идеја.

На срећу, постоји и трећа могућност, а то је управо употреба наслеђивања. Наслеђивање нам 
омогућава да добијемо то што колега има већ урађено, а да при томе нити реметимо не његов рад 
мењајући постојећу класу, нити умножавамо постојећи кôд, компликујући одржавање. 

Базна и изведена класа
----------------------

Механизам наслеђивања нам омогућава да направимо нову класу, користећи неку постојећу класу као 
полазну основу. Ту полазну класу називамо **базна класа**, а нову класу **изведена класа**. Када 
помоћу механизма наслеђивања формирамо нову класу на основу постојеће, нова класа одмах (без 
копирања кода) садржи сву функционалност базне класе, коју може по потреби делимично да преиначи 
и/или допуни. 

Да би поља базне класе била доступна у методима изведене класе, довољно је да та поља у базној 
класи буду декларисана као **заштићена** (``protected``) уместо као приватна (``private``).
Тако декларисана поља ће у свим осталим класама (које нису изведене из базне) и даље бити 
недоступна, исто као када их декларишемо као приватна.

.. csv-table:: 
    :header: **Доступност**, ``public``, ``protected``, ``private``
    :widths: 40, 15, 15, 30
    :align: left

    **Унутар исте класе**,       ✅, ✅, ✅
    **Унутар изведених класа**,  ✅️, ✅, ❌
    **Из осталих класа**,    ✅️, ❌, ❌


.. comment

    У програмирању је честа ситуација да нам постојећи кôд одговара делимично, али не у потпуности. 
    Тај исти постојећи кôд неком другом вероватно одговара у потпуности, па не можемо само да га 
    преправимо и прилагодимо својим потребама, јер бисмо тиме пореметили рад других програмера. Могли 
    бисмо да направимо копију кода који нам је потребан, па да ту копију прилагодимо, али такво решење 
    није препоручљиво. Наиме, на такав начин се гомилају веома слични делови кода и програм брзо 
    постаје непотребно велики и тежак за одржавање (нпр. исправке грешака и друге будуће измене треба 
    уносити на више места у коду) и непрегледан (лако можемо да помешамо у којој од неколико истих или 
    сличних функција се налазимо). Боље решење нам доноси управо наслеђивање. Постојећи кôд треба сместити 
    у класу, а нову класу треба извести из постојеће. На тај начин постојећи кôд не мора ни да се мења, 
    ни да се копира, а ми добијамо класу која је делом иста као нека постојећа, а разликује се у делу 
    у коме нам је то потребно. Ово ћемо ускоро да илуструјемо на примерима.


Писање и понашање изведене класе
--------------------------------

**Навођење базне класе као полазне основе за нову класу**

Јасно је да приликом писања дефиниције изведене класе треба негде да се наведе из које класе се 
изводи та класа, да би компајлер имао све потребне информације за генерисање извршивог кода. Име 
базне класе се наводи након имена изведене класе и двотачке. На пример, ако изводимо класу ``B`` 
из класе ``A``, треба писати:

.. code::

    public class A
    {
        // ...
    }

    public class B : A
    {
        // ...
    }

**Процес креирања објекта изведене класе, писање конструктора**

Приликом креирања инстанце изведене класе, потребно је да се иницијализује и онај део објекта 
који постоји и у базној класи. Пошто се то већ дешава у конструктору базне класе (а може да буде 
сложен поступак), било би непрактично да се кôд за иницијализацију основног дела понавља у 
конструктору изведене класе. Стога је механизам наслеђивања осмишљен тако да се при инстанцирању 
изведене класе **увек** прво позива конструктор базне класе, а затим конструктор изведене класе. 
На тај начин нам је омогућено да се конструктором изведене класе само надовежемо на оно што ради 
конструктор базне класе и да његов рад само допунимо (и евентуално модификујемо колико је 
потребно), али не морамо да га понављамо. 

.. comment

    слика са два оквира, један у другом (објекат базне и изведене класе). 
    Поља базне у унутрашњем, а поља изведене у спољашњем оквиру.

Приликом писања конструктора изведене класе, **имамо могућност да наведемо који конструктор базне 
класе желимо** да се изврши пре њега (а неки мора да се изврши), и са којим аргументима. Аргументе 
конструктора базне класе наводимо након листе аргумената конструктора изведене класе, двотачке и 
кључне речи ``base``, на пример:

.. code::

    public class A
    {
        protected int x;
        public A(int x0) { x = x0; }
        // ...
    }

    public class B : A
    {
        private int y;
        public B(int x0, int y0)
            : base(x0)
        {
            y = y0;
        }
        // ...
    }

Ако базна класа има више конструктора, компајлер на основу броја и типа аргумената наведених иза 
речи ``base`` одређује који од њих треба да буде изрвршен. Уколико базна класа има и конструктор 
без параметара, део ``: base(<lista ragumenata>)`` можемо и да изоставимо, а у том случају ће да 
буде извршен консруктор базне класе без параметара. Уколико базна класа нема такав конструктор, 
реч ``base`` и листу аргумената морамо да наведемо. 


Примери наслеђивања
-------------------

Призводи и намирнице
^^^^^^^^^^^^^^^^^^^^

У следећем једноставном примеру појављују се две класе. Класа ``Proizvod`` је општија и служи као 
базна класа за класу ``Namirnica``, коју можемо да схватимо као специјалну врсту производа. У овом 
примеру, поред особина које има сваки производ (назив и цена), намирница има и додатне особине 
(маса и рок трајања). Једино "понашање" које имају ове две класе је враћање текстуалне репрезентације 
свог објекта. 

.. activecode:: klase_proizvod_namirnica
    :passivecode: true

    using System;

    namespace Program
    {
        public class Proizvod
        {
            protected string naziv;
            protected int cena;
            public Proizvod(string naziv, int cena)
            {
                this.naziv = naziv;
                this.cena = cena;
            }
            public string Naziv { get { return naziv; } }
            public int Cena { get { return cena; } }
            public override string ToString()
            {
                return string.Format("{0}, {1}din.", naziv, cena);
            }
        }
        public class Namirnica : Proizvod
        {
            private int masa;
            private DateTime rok;
            public Namirnica(string naziv, int masa, int cena, DateTime rok) : base(naziv, cena)
            {
                this.masa = masa;
                this.rok = rok;
            }
            public int Masa { get { return masa; } }
            public DateTime RokTrajanja { get { return rok; } }
            public override string ToString()
            {
                return string.Format("{0}, masa: {1}, upotrebljivo do {2}, {3}din.",
                    naziv, masa, rok.ToString("dd.MM.yyyy"), cena);
            }
        }

        class Program
        {
            static void Main(string[] args)
            {
                Proizvod sijalica = new Proizvod("Sijalica", 250);
                Proizvod mleko = new Namirnica("Mleko", 120, 1000, DateTime.Now.AddDays(2));
                Namirnica sir = new Namirnica("Sir", 400, 200, DateTime.Now.AddDays(30));

                Console.WriteLine(sijalica);
                Console.WriteLine(sir);
                Console.WriteLine(mleko);

                Console.WriteLine("Cena sijalice je {0}", sijalica.Cena);
                Console.WriteLine("Cena mleka je {0}", mleko.Cena);
                Console.WriteLine("Cena sira je {0}", sir.Cena);

                //Console.WriteLine("Masa sijalice je {0}", sijalica.Masa);
                //Console.WriteLine("Masa mleka je {0}", mleko.Masa);
                Console.WriteLine("Masa sira je {0}", sir.Masa);
            }
        }
    }

Програм исписује 

.. code::

    Sijalica, 250din.
    Sir, masa: 400, upotrebljivo do 29.04.2023, 200din.
    Mleko, masa: 120, upotrebljivo do 01.04.2023, 1000din.
    Cena sijalice je 250
    Cena mleka je 1000
    Cena sira je 200
    Masa sira je 400


Возила и аутобуси
^^^^^^^^^^^^^^^^^

У овом примеру, класа ``Vozilo`` је базна, општија класа, а из ње се изводи класа ``Autobus``, 
као специјална врста возила. Класа ``Vozilo`` садржи поља ``potrosnja``, ``kilometraza`` и 
``uRezervoaru``, што су подаци карактеристични за свако возило. Класа ``Autobus`` поред ових 
података садржи и податке ``brSedista`` и ``brPutnika``, који су посебно значајни за аутобусе, 
а нису толико битни за остала возила. Слично томе, у класи ``Vozilo`` дефинисани су методи 
``Natoci`` и ``Predji``, као и својство ``Domet``, које опет треба да има свако возило. Класа 
``Autobus`` допуњује ову функционалност методима ``Ulaz`` и ``Izlaz``, специфичним за возила 
која се баве масовнијим превозом путника, тј. за аутобусе. Осим тога, класа ``Autobus`` има и 
својство ``BrPutnika``, које се односи на тренутни број путника у аутобусу. 



.. activecode:: nasledjivanje_vozilo
    :passivecode: true
    :includesrc: src/primeri/nasl_vozilo.cs
  
Програм исписује

.. code:: 
     
    400
    100
    15

Наслеђивање као однос између класа
----------------------------------

До сада смо имали прилике да видимо различите облике сарадње између класа. Чест случај је био да 
једна класа **креира**, а затим и **користи** објекте друге класе. На пример, у свакој конзолној 
апликацији класа ``Program`` креира и користи објекте осталих класа. Ову врсту односа зовемо 
**асоцијација**.

Било је и ситуација у којима објекат једне класе у својој дефиницији **садржи** референце на 
објекте других класа. На пример, класа ``Prava`` садржи референце на једну тачку и један вектор. 
Такође, у графичким апликацијама класа која представља форму типично садржи референце на све 
остале класе које се појављују у апликацији. Ову врсту односа зовемо **агрегација**.

Наслеђивање представља нову врсту односа између класа, који називамо **специјализација**. То значи 
да објекти изведене класе могу да се посматрају као посебна врста објеката базне класе. У нашем 
првом примеру, намирница је посебна, специјална врста производа, а у другом, аутобус је посебна 
врста возила. У свим примерима наслеђивања, објекат изведене класе треба да буде у стању да одигра 
улогу објекта базне класе, тј. да уме све што уме и објекат базне класе (а може да уме и више). 
Другим речима, кôд који користи објекте базне класе треба да буде у стању да уместо њих употреби 
објекте изведене класе, а да то не мора ни да зна. 

.. comment

    Могући односи између класа: користи, агрегира/садржи, наслеђује.
    Разлика између "агрегира" и "садржи" није битна ако се ослањамо на ђубретарца (нема власника).

    - има, садржи (`has a`)
    - је врста од (`is a`)

