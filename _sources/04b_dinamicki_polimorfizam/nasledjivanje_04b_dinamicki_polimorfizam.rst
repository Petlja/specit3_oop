Динамички полиморфизам
======================

У овој лекцији:

- шта је виртуелан, а шта апстрактан метод
- шта је апстрактна класа
- шта је динамички полиморфизам

.. comment

    Пример игрице у којој учествују различити кaрактери

    .. code::

        abstract class Karakter
            PrikaziSe();
            
    Разни карактери се приказују на различите начине. 

    - Непокретан карактер може само да нацрта своју битмапу на својој локацији
    - Покретан карактер може да користи једну од неколико битмапа, зависно од тога да ли стоји или се креће у неком смеру
    - Неки карактери могу да се приказују помоћу две или више битмапа (нпр. према томе како држе оружје)
    - Неки карактери могу да преко своје битмапе нацртају одређене ефекте у складу са акцијом коју предузимају

Редефинисање метода
-------------------

**Причица - шта подразумевамо под редефинисањем.** Сценарио - функционалност коју желимо

**Слика** - базна класа са ``abstract`` или ``virtual``, изведене класе са ``override`` или ничим.
Оне пре ``override`` су или апстрактне или користе дифолт, а оне после користе редефиницију.

Метод који је предвиђен за накнадно редефинисање, на месту првог помињања треба да буде означен 
као апстрактан (``abstract``) или као виртуелан (``virtual``). 

- ``abstract`` значи да метод није дефинисан и да треба да буде дефинисан у класама наследницама, 
  за које желимо да имају инстанце.
- ``virtual`` значи да је метод дефинисан и намењен за редефинисање. Овај метод је подразумевани за 
  класе наследнице (важи за класе које га не редефинишу).

Ако је метод означен као апстрактан, редефинисање је обавезно, а ако је означен као виртуелан, 
редефинисање је могуће али није обавезно. Свако накнадно редефинисање у некој од класа наследница, 
означава се речју ``override``.

- ``override`` значи да се метод редефинише у односу на неку њему базну класу, а може (и не 
  мора) да се даље редефинише у класама наследницама.

.. comment

    Метод може да буде уведен и у некој од класа из библиотеке, из које изводимо неку своју класу.
    Да би у изведеној класи могао да буде редефинисан помоћу ``override``, метод мора да постоји у 
    некој базној класи и да у њој буде означен као ``virtual``, ``abstract``, или ``override``.

Пример динамичког полиморфизма
------------------------------

У примеру који следи појављују се два истоимена метода ``f``, један у класи ``B``, а други у класи 
``C``. Овакво појављивање истоимених метода је такође један облик полиморфизма, али другачији од 
оног који познајемо од раније. 

.. activecode:: dinamicki_polimorfizam
    :passivecode: true
    :includesrc: src/primeri/nasl_dinamicki_polimorfizam.cs

У случају да у датом примеру корисник унесе слово ``b``, биће позван конструктор класе ``B``, а 
у противном ће бити позван конструктор класе ``C``. Након тога, позива се метод ``f`` оне класе 
чији конструктор је креирао објекат ``a`` (испробајте ово). 

Очигледно, компајлер у време превођења програма на машински кôд не може да зна да ли ће објекат 
``a`` бити креиран конструктором класе ``B`` или класе ``C``. Самим тим, компајлер не може да 
разреши на који метод ``a`` се односи позив ``a.f()``. Ова дилема може да се разреши једино у 
време извршавања програма, па се зато овај облик полиморфизма назива динамички полиморфизам. 
Подсетимо се, за разлику од овог облика полиморфизма, статички полиморфизам представља појаву 
истоимених метода у једној класи, а може да се разреши (и разрешава се) у време компајлирања 
јер се такви истоимени методи разликују по листама параметара.

.. reveal:: jedinstveni_id
    :showtitle: Како се разрешава динамички полиморфизам?
    :hidetitle: Сакриј текст о разрешавању динамичког полиморфизма

    **Како се разрешава динамички полиморфизам?**

    За класу која има виртуелне методе компајлер формира табелу, у којој сваки ред табеле одговара 
    једном виртуелном методу. Када се објекат инстанцира, та табела се попуњава адресама актуелних 
    (стварних) метода. Касније, када неки од метода буде позван, у табели се проналази адреса 
    конкретног метода који треба позвати. 
    
    За више информација, потражите појам **табела виртуелних метода** 
    (`virtual method table <https://en.wikipedia.org/wiki/Virtual_method_table>`_).
