Виртуелни методи
================

У овој лекцији:

- Шта нам доносе (зашто су корисни) виртуелни методи
- Како се пишу и употребљавају виртуелни методи
- Виртуелни методи као облик динамичког полиморфизма


При раду са правоугаоницима из претходног примера (види лекцију `Основно о наслеђивању`), може да 
се јави потреба да формирамо низ правоугаоника и да затим нешто израчунамо на основу координата 
њихових темена. Неки од тих правоугаоника могу да буду поравнати са координатним осама, а неки 
ротирани у односу на осе. То значи да у низу могу да се појаве и објекти класе ``Pravougaonik`` и 
они класе ``RotiraniPravougaonik``. Према томе, низ треба да буде декларисан као низ референци на 
базну класу, а те референце могу да указују на објекте било базне, било изведене класе. 

.. code-block:: csharp

    int n = int.Parse(Console.ReadLine());
    Pravougaonik[] a = new Pravougaonik[n];
    ...

У претходној лекцији видели смо да оваква употреба класе ``RotiraniPravougaonik`` може да доведе 
до погрешних резултата. Наиме, када се ротираном правоугаонику приступа преко референце на базну 
класу, извршавају се методи (укључујући и приступнике својстава) базне класе. Међутим, методи базне 
класе не знају за могућност ротације, па ће рачунати координате као да правоугаоник није ротиран. 

Да бисмо и поравнате и ротиране правоугаонике могли да држимо у истом низу и користимо не обраћајући 
пажњу на то који је ког типа, потребан нам је нови механизам, који ће да узме у обзир днамичку 
природу објеката. Имајмо на уму да се у неким ситуацијама одлука о томе који конструктор ће бити 
позван доноси тек у време извршавања програма, као што показује следећи пример.


.. code-block:: csharp

    Pravougaonik p2;
    Console.WriteLine("Da li da naprvim obican ili rotirani pravougaonik?");
    string odgovor = Console.ReadLine();

    if (odgovor == "obican")
        p2 = new Pravougaonik(1, 1, 0, 0);
    else
        p2 = new RotiraniPravougaonik(5, 5, 0, 0, Math.PI/4);

    Console.WriteLine("Tacka B je B({0:0.00}, {1:0.00}), ", p2.BX, p2.BY);

Овде одлука зависи од уноса корисника, па је јасно да у време комплајлирања програма не знамо 
(а не зна ни компајлер) ког типа ће бити објекат на који указује референца ``p2``. Пошто објекат 
може да буде било ког типа, потребно је да се код позива метода (или извршавања свосјтава) узме 
у обзир стварна природа објекта, тј. његов стваран тип. Ту могућност нам доносе виртуелни методи. 


Употреба виртуелних метода
--------------------------

Виртуелни методи су начин да компајлеру кажемо да при позивању метода не проналази метод који ће 
да се изврши на основу декларације, већ на основу стварног типа актуелног објекта. За методе и 
својства код којих желимо такво понашање, у базној класи треба да напишемо реч ``virtual`` испред 
имена метода, односно својства. Тиме и даље омогућавамо изведеним класама да користе метод или 
својство базне класе такве какви су, ако им то одговара. Другим речима, виртуелан метод је 
**подразумевано понашање** и оно ће бити примењено ако изведена класа не зада другачије понашање. 
Са друге стране, изведеним класама остављамо могућност и да редефинишу ове (виртуелне) методе на 
такав начин, да се у претходно описаној ситуацији при позиву користи тај редефинисани метод. 
Када је метод у базној класи означен као виртуелан, у изведеној класи га редефинишемо тако што испред 
имплементације истоименог метода додамо реч ``override``. 

|

Ево како можемо да преправимо пример са правоугаоницима, да би се при употреби објеката преко 
референци на базну класу добило понашање у складу са стварним типом објекта.

.. code-block:: csharp

    public class Pravougaonik
    {
        protected double w, h;
        protected double ax, ay;
        public Pravougaonik(double w, double h, double ax, double ay)
        {
            this.w = w;
            this.h = h;
            this.ax = ax;
            this.ay = ay;
        }

        public double Obim() { return 2 * w + 2 * h; }
        public double Povrisna() { return w * h; }

        public double W { get { return w; } }
        public double H { get { return h; } }

        virtual public double AX { get { return ax; } }
        virtual public double AY { get { return ay; } }
        virtual public double BX { get { return ax + w; } }
        virtual public double BY { get { return ay; } }
        virtual public double CX { get { return ax + w; } }
        virtual public double CY { get { return ay + h; } }
        virtual public double DX { get { return ax; } }
        virtual public double DY { get { return ay + h; } }
    }
    public class RotiraniPravougaonik : Pravougaonik
    {
        private double sinUgla;
        private double cosUgla;
        public RotiraniPravougaonik(double a, double b,
            double ax, double ay, double ugao)
            : base(a, b, ax, ay)
        {
            this.sinUgla = Math.Sin(ugao);
            this.cosUgla = Math.Cos(ugao);
        }
        override public double BX { get { return ax + w * cosUgla; } }
        override public double BY { get { return ay + w * sinUgla; } }
        override public double CX { get { return BX - h * sinUgla; } }
        override public double CY { get { return BY + h * cosUgla; } }
        override public double DX { get { return ax - h * sinUgla; } }
        override public double DY { get { return ay + h * cosUgla; } }
    }

Извршимо следећих неколико наредби са овако написаним класама.

.. code-block:: csharp

    Pravougaonik p2;
    Console.WriteLine("Da li da naprvim obican ili rotirani pravougaonik?");
    string odgovor = Console.ReadLine();

    if (odgovor == "obican")
        p2 = new Pravougaonik(1, 1, 0, 0);
    else
        p2 = new RotiraniPravougaonik(5, 5, 0, 0, Math.PI/4);

    Console.WriteLine("Tacka B je B({0:0.00}, {1:0.00}), ", p2.BX, p2.BY);

Уношењем различитих одговора можемо да се уверимо да се овај пут добија исправан резултат и када је 
објекат типа ``Pravougaonik``, као и када је типа ``RotiraniPravougaonik``. 

.. infonote::

    Различито понашање једнако третираних објеката (у складу са њиховим стварним типом) је појава коју 
    називамо **динамички полиморфизам**. Реч полиморфизам смо раније објаснили као појављивање у више 
    облика, а овај вид полиморфизма називамо динамички, јер је тип објекта познат тек у време извршавања 
    програма. 
    
    Подсетимо се, раније смо помињали статички полиморфизам, који подразумева употребу више истоимених 
    метода у оквиру једне класе. Ти методи се разликују по броју и типу праметара, па сваки од позива 
    тих метода може да се разреши статички, тј. у време превођења (комплајлирања) програма. 

Динамичким полиморфизмом ћемо се бавити у већем делу овог поглавља, а у наредним поглављима ћемо видети 
и његове реалне примене. За сада можемо да кажемо да је пример са правоугаоницима први пример динамичког 
полиморфизма са којим се сусрећемо у овом курсу. 


.. suggestionnote::

    Декларисање објеката (тј. референци) помоћу базне класе, а инстанцирање и помоћу базне и помоћу 
    разних изведених класа је честа пракса у објектно оријентисаном програмирању, која доноси велике 
    погодности. Зато је важно да научимо како да правилно користимо ову могућност и да добро разумемо 
    њене ефекте. 
