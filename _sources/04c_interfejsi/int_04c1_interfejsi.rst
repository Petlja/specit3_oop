Интерфејси
==========

У овој лекцији:

- Шта је вишеструко наслеђивање
- Шта је интерфејс и како се разликује од апстрактне класе
- Примери имплементирања интерфејса из .Net библиотеке
- Креирање и имплементирање сопствених интерфејса


Појам интерфејса
----------------

У одређеним ситуацијама се јавља потреба да једна класа има више базних класа, тј. да наследи више 
различитих класа. Овакав облик наслеђивања се назива **вишеструко наслеђивање** (скраћено: в.н.). 
Око овог концепта било је много полемике још од његовог увођења, а мишљења нису у потпуности 
усаглашена ни данас. Наиме, многи научници рачунарства мисле да в.н. уводи сувише проблема (компликује 
језик и његову имплементацију, повећава шансе појављивања багова због погрешне употребе в.н.) и да због 
тога не треба да буде подржано у програмским језицима, док неки и даље мисле да програмски језици 
треба да га омогуће, а да је на програмерима да савладају његову правилну употребу и тако заобиђу 
могуће проблеме. Због тога данас неки језици подржавају вишеструко наслеђивање, а неки не. Типично, 
новији језици су ти који не подржавају в.н. а уместо њега уводе неке сличне концепте, који нуде 
приближно исте могућности уз мање ризика од погрешне употребе. Постојећи концепти који служе као 
замене за вишеструко наслеђивање и даље се развијају и мењају. Са друге стране, разни језици који 
дозвољавају в.н. имају различите додатне захтеве за писање кода (у смислу синтаксе), како би се 
смањила могућност грешке. 

Темом вишеструког наслеђивања и могућим проблемима који са њим долазе нећемо се овде даље бавити, 
а заинтересовани читаоци могу да нађу више информација већ на страници Википедије `о вишеструком 
наслеђивању <https://en.wikipedia.org/wiki/Multiple_inheritance>`_. 

У језику `C#`, наслеђивање више класа није могуће. Сродан концепт који у великој мери надокнађује 
потребу за вишеструким наслеђивањем се у језику `C#` назива **интерфејс**. До сада смо реч интерфејс 
користили мање формално, да означимо јавни (изложени) део класе. Сада се срећемо са новим, друкчијим 
значењем ове речи.

.. infonote:: 

    У језику `C#`, **интерфејс** је посебан језички конструкт који пре свега служи да зада декларације 
    (потписе) једног или више метода. Поред метода, интерфејс може да садржи декларације својстава, 
    индексера и догађаја. За класу која садржи дефиниције метода и других чланова декларисаних у 
    интерфејсу, каже се да **имплементира дати интерфејс**. 

    У неким програмским језицима уместо речи интерфејс користи се реч протокол, а уместо да се 
    каже да класа имплементира интерфејс, каже се да класа усваја (енгл. `adopts`) протокол. 
    Реч је о суштински истом концепту. 

Појам интерфејса је врло близак појму апстрактне класе, јер оба садрже "најављене", тј. декларисане 
методе (и друге чланове) без дефиниције. Главна разлика је у томе што **интерфејс не може да садржи 
нестатичка поља са подацима**. На пример, раније уведена апстрактна класа ``Figura3D`` не би (таква 
каква је) могла да се напише као интерфејс, јер садржи референцу ``osnova`` на класу ``Figura2D``, 
као и реалан податак ``visina``. У том смислу, **интерфејс можемо да схватимо као апстрактну класу 
без (нестатичких) података**. Из ове разлике између интерфејса и апстрактних класа проистиче и 
разлика у употреби, а то је да остале класе могу да имплементирају више интерфејса, али могу да 
наследе само једну класу, било апстрактну или не. То и јесте основни разлог за увођење интерфејса. 

У новијим верзијама језика `C#` разлике између интерфејса и апстрактних класа се све више смањују, 
са идејом да интерфејси дају што више могућности које би донело вишеструко наслеђивање класа, али 
тако да не уведу и исте проблеме.



.. comment

    Ово није поуздано, ваљало би испробати!
    
    **Детаљније разлике између апстрактне класе и интерфејса су наведене у следећој табели.**

    .. csv-table:: 
        :header: **Апстрактна класа**, **Интерфејс**
        :widths: 50, 50
        :align: left

        "Може да има конструкторе.",                                                "Може да има само статички конструктор (који иницијализује само статичке чланове)."
        "Може да садржи и дефиниције метода.",                                      "Може да садржи дефиниције само статичких метода (са разрешавањем имена у време компајлирања)."
        "Може да садржи и виртуелне методе.",                                       "Може да садржи само статичке виртуелне методе (са разрешавањем имена у време компајлирања)."
        "Може да садржи поља",                                                      "Може да садржи само статичка поља."
        "Може да садржи константе",                                                 "Може да садржи само статичке константе."
        "**Класа наследница не мора да имплементира све њене апстрактне методе**.", "**Класа која имплементира интерфејс, мора да имплементира све његове недефинисане методе**."
        

Имплементирање интерфејса из .Net библиотеке
--------------------------------------------

Један важан разлог за упознавање интерфејса је правилна употреба интерфејса из библиотеке `.Net`. 
Погледајмо пар примера у којима је корисно да наше класе имплементирају неке од интерфејса из 
библиотеке.

Пример -- сортирање низова и листи (интерфејс ``IComparable``)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Подсетимо се примера са разломцима са почетка овог курса. Написали смо једну релативно богату 
класу, која омогућава читање, исписивање и рачунање са разломцима на исти начин као што се то 
ради са целим или реалним бројевима. Ипак, тиме нисмо достигли пуну функционалност, коју би 
неко могао да очекује од класе ``Razlomak``. На пример, са постојећом имплементацијом класе 
није могуће сортирати низ разломака. Ако бисмо писали

.. code-block:: csharp

    int n = int.Parse(Console.ReadLine());
    Razlomak[] r = new Razlomak[n];
    for (int i = 0; i < n; i++)
        r[i] = Razlomak.Parse(Console.ReadLine());

    Array.Sort(r);


програм би могао да се покрене, али би пукао током извршавања наредбе ``Array.Sort(r);``. Тачније, 
програм би бацио изузетак и добили бисмо следећу поруку:

| System.InvalidOperationException: 'Failed to compare two elements in the array.'
| Inner Exception
| ArgumentException: At least one object must implement IComparable.

Ово значи да статички метод ``Sort`` класе ``Array`` тек приликом покушаја да упореди два елемента 
низа ``r`` открива да му није доступан метод помоћу кога би могао да изврши поређење. Мада смо у 
класи ``Razlomak`` дефинисали метод ``CompareTo``, нигде нисмо саопштили да је то метод који друге 
класе (нпр. оне из библиотеке) треба да користе за поређење инстанци класе ``Razlomak``. Управо у 
ту сврху је у библиотеци дефинисан интерфејс ``IComparable``. 

.. suggestionnote::

    Када нека класа имплементира интерфејс ``IComparable``, друге класе је виде као класу чије 
    инстанце могу да се пореде методом ``CompareTo``.

Према томе, да бисмо могли да сортирамо бројеве на наведени начин, потребно је да мало преправимо 
класу ``Razlomak``. Конкретно, уместо

.. code-block:: csharp

    public class Razlomak
    {
        // ...

        public int CompareTo(Razlomak r)
        {
            return a * r.b - r.a * b;
        }

        // ...
    }

треба да пишемо 

.. code-block:: csharp

    public class Razlomak : IComparable
    {
        // ...

        public int CompareTo(Object obj)
        {
            Razlomak r = obj as Razlomak;
            return a * r.b - r.a * b;
        }

        // ...
    }

Сада се претходне наредбе за сортирање низа разломака извршавају баш онако како смо и очекивали. 

Из овог примера видимо да се интерфејс који дата класа имплементира наводи после имена класе и 
двотачке, потпуно исто као и базна класа коју дата класа наслеђује. Друга измена је измена типа 
параметра метода ``CompareTo``. Она је потребна зато што је је таква декларација овог метода у 
библиотечком интерфејсу.
        
.. comment

    .. reveal:: dugme_razlomci_sa_pocetka
        :showtitle: Програм са класом разломци
        :hidetitle: Сакриј програм са класом разломци

        .. activecode:: poredjenje_razlomaka2
            :passivecode: true
            :includesrc: src/primeri/poredjenje_razlomaka.cs

            :includesrc: src/primeri/ucitavanje_razlomaka.cs
            :includesrc: src/primeri/racunanje_sa_razlomcima.cs


Пример -- наредба ``using`` (интерфејс ``IDisposable``)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

У Петљином курсу за први разред објашњено је да постоји више начина да упишемо податке у текстуални 
фајл, користећи објекат ``StreamWriter``. Један начин подразумева експлицитно затварање фајла помоћу 
метода ``Close``.

.. code-block:: csharp

    StreamWriter sw = new StreamWriter(putanja);  // Отвори фајл за писање
    sw.Write("...");                              // Пиши у фајл
    sw.WriteLine("...");                          // Пиши у фајл
    // ...
    sw.Close();                                   // Затвори фајл

Други, новији начин подразумева употребу наредбе ``using``, која аутоматски води рачуна о 
затварању фајла. 

.. code-block:: csharp

    using (StreamWriter sw = new StreamWriter(putanja))
    {
        sw.Write("...");
        sw.WriteLine("...");
        // ...
    }

.. comment

    Приликом извршавања наредби за писање у фајл, текст се не уписује одмах на диск, јер 
    би такав начин рада био врло спор (приступ диску је за неколико редова величине спорији од приступа 
    радној меморији рачунара). Уместо директног писања на диск, текст се уписује у одговарајући бафер 
    (`buffer`), тј. меморију специјално намењену за чување текста до уписа на диск. Текст се уписује 
    на диск тек кад се бафер напуни, или када се то експлицитно захтева (нпр. методом ``Flush()``). На 
    тај начин се смањује број приступа диску и успорење програма које тиме настаје (енглеска реч `buffer` 
    у овом контексту значи ублаживач, јер употреба поменуте меморије ублажава проблем успорења програма).

    У току рада програма, након отварања а пре затварања фајла може да наступи изузетак (`exception`) 
    због покушаја извршавања неке тренутно неизводљиве операције (нпр. приступ непостојећем елементу 
    низа, дељење нулом и слично). 
    У том случају наредбе у наставку програма, међу којима је и наредба за затварање фајла, неће бити 
    извршене, већ се прелази на наредбе за обраду изузетка, ако такве наредбе постоје (блок ``catch`` 
    у наредби ``try-catch``). Ако наредбе за обраду изузетка нису наведене, програм пукне.

    Незатварање фајла је већ само по себи лоше, јер су заузети ресурси који више не могу да се користе. 
    Додатни проблем је што део текста може да заостане у баферу и да не буде уписан на диск, чиме долази 
    и до губитка података. 

Подсетимо се укратко по чему је други начин бољи од првог, тј. зашто је језик проширен наредбом 
``using``. Употреба наредбе ``using`` гарантује да ће фајл бити затворен чак и у случају да током 
употребе објекта ``sw`` наступи изузетак. Самим тим гарантује се и да ће пре затварања фајла сви 
подаци бити преписани из бафера на диск, као и да ће бити ослобођени ресурси оперативног система 
(`file handle`), који омогућавају да се фајл држи отвореним. У случају незатварања фајла (први 
начин писања података у фајл), може да дође до губитка података заосталих у баферу фајла, као и 
до продуженог заузећа ресурса, а тиме и до успореног рада система и ометања других програма у 
њиховом раду.
    
Сличне проблеме можемо да имамо и када објекти наше класе држе неке ресурсе отворене. То може да 
буде интернет конекција, велика количина меморије (нпр. велики ``Bitmap`` објекат) или било који 
други ресурс. Истина је да ће меморија свакако бити ослобођена посредством сакупљача отпада (енгл. 
`garbage collector`), али до тада може да прође извесно време, а да у међувремену систем буде 
успорен због недостатка оперативне меморије. Без обзира на то о којој врсти ресурса се ради, било 
би добро да предности наредбе ``using`` можемо да користимо и за инстанце наше класе. Конкретно, 
било би корисно да уместо 

.. code-block:: csharp

    MojaKlasa a = new MojaKlasa();
    // koristi objekat a
    // ...

можемо да пишемо 

.. code-block:: csharp

    using (MojaKlasa a = new MojaKlasa())
    {
        // koristi objekat a
        // ...
    }

Ако ово покушамо, добијамо следећу синтаксну грешку приликом компајлирања програма:

| Error	CS1674	'MojaKlasa': type used in a using statement must be implicitly convertible to 'System.IDisposable'.	

Ово значи да класа ``MojaKlasa`` треба да имплементира интерфејс ``IDisposable``, односно његов 
једини метод ``void Dispose()``, да би могла да буде употребљена у наредби ``using``. Следећи мали 
пример показује како то може да се уради.

.. code-block:: csharp

    public class MojaKlasa : IDisposable
    {
        Bitmap bmp;
        public MojaKlasa() 
        {
            bmp = new Bitmap(10000, 10000);
        }

        public void Dispose()
        {
            Console.WriteLine("Pozvan metod A.Dispose");
            bmp.Dispose();
        }
    }


    // ...
    
    using (MojaKlasa a = new MojaKlasa())
    {
        Console.WriteLine("Upotreba objekta a");
    }
    Console.WriteLine("kraj programa");

Извршавањем последња три реда исписује се

.. code::
    
    Upotreba objekta a
    Pozvan metod A.Dispose
    kraj programa
    
Поред синтаксе потребне за имплементацију интерфејса ``IDisposable``, пример показује да се по 
изласку из тела наредбе ``using`` позива метод ``Dispose()`` објекта ``a``, што је и поента 
целог примера. Наравно, исписивање је додато само да би могао да се испрати редослед извршавања. 
У реалној употреби у методу ``Dispose()`` би се нашле све потребне наредбе за ослобађање ресурса 
које је објекат ``a`` заузимао. У овом примеру, то је само наредба ``bmp.Dispose()``, која 
ослобађа све ресурсе које је заузимао објекат ``bmp``. 

Интерфејс IEnumerable
---------------------

.. comment

    Вероватно сте већ користили листе на неке (или све) начине показане у следећем програму:

    .. activecode:: ienumerable_samo_lista
        :passivecode: true
        :includesrc: src/primeri/ienumerable_samo_lista.cs

Када већ говоримо о интерфејсима, искористићемо прилику да нешто детаљније представимо један који 
често користимо, а да тога можда нисмо ни свесни. То је интерфејс ``IEnumerable``. Многе библиотечке 
колекције, као што су ``Stack``, ``Queue``, ``List``, ``SortedSet`` и друге, имплементирају овај, 
као и неке друге интерфејсе. Међутим, управо имплементирање интерфејса ``IEnumerable`` је оно што 
колекције чини колекцијама. Ако се запитамо које су то карактеристичне активности, које обављамо 
над свим колекцијама, вероватно ћемо се сетити итерирања кроз колекцију, претраживања (провере да 
ли колекција садржи одређени елемент), филтрирања (издвајања елемената са одређеном особином) и 
слично. Испосатавља се да све ове активности можемо да обављамо над сваком класом која имплементира 
интерфејс ``IEnumerable``.

Као што знамо, за **итерирање** кроз различите колекције користи се наредба ``foreach``. Ова наредба 
се сматра удобнијом и безбеднијом од наредбе ``for``, јер индексирање није потребно, а спречава се 
и могућност приступања непостојећем елементу колекције (када је индекс ван граница). Наредбу 
``foreach`` сте до сада вероватно користили над низовима, листама, скуповима и речницима, а можда и 
над још неким колекцијама, дефинисаним у стандардној библиотеци. Оно што до сада нисмо истицали је да 
наредба ``foreach`` може да се користи **над сваком класом која имплементира интерфејс** ``IEnumerable``.
На пример, пошто стекови и редови имплементирају овај интерфејс, петља ``foreach`` може да се користи 
чак и над њима, мада одговарајући теоријски апстрактни типови својим интерфејсом не допуштају итерирање, 
већ само приступ једном елементу (оном на врху стека, односно првом у реду). 

Поред итерирања помоћу наредбе ``foreach``, над класама које имплементирају интерфејс ``IEnumerable`` 
можемо да итерирамо и користећи помоћни објекат, који се назива **енумератор** (набрајач). За овакво 
итерирање довољни су метод ``MoveNext`` и својство ``Current`` енумератора, што може да се види у 
програму који следи.

Овде се подршка интерфејсу ``IEnumerable`` не завршава, јер за класе које га имплементирају доступан 
је и **велики број метода** из именског простора ``System.Linq`` стандардне библиотеке. То су, на 
пример, методи који враћају неку специфичну вредност из колекције (``First``, ``Last``, ``Min``, 
``Max``...), методи који враћају резултат неке агрегатне функције над колекцијом (``Any``, ``All``, 
``Sum`, ``Count``, ``Average``, ``Contains``...), као и методи-упити, који враћају друге колекције, 
односно референце на интерфејс ``IEnumerable`` (``Where``, ``Distinct``, ``Union``, ``Intersect``, 
``Except``, ``Select``, ``GroupBy``, ``Take``...). Друге колекције се добијају од постојећих помоћу 
операција пресека, уније, разлике, филтрирањем и другим сличним операцијама.

Следећи програм показује употребу интерфејса ``IEnumerable``, односно инстанци класа које 
имплементирају овај интерфејс. Сви ти објекти се користе на исти начин, без обзира на њихов стварни 
тип. Поменимо још да интерфејс ``IEnumerable`` може да се користи и као негенерички (не дефинишући 
тип елемената), и као генерички, нпр. ``IEnumerable<int>`` или ``IEnumerable<char>``, као што је и 
учињено у овом програму.

.. activecode:: ienumerable_kolekcije
    :passivecode: true
    :includesrc: src/primeri/ienumerable_kolekcije.cs

Програм исписује:

.. code::

    Tip kolekcije: System.Collections.Generic.Stack`1[System.Int32]
    Iteriranje kroz kolekciju pomocu enumeratora: 3 2 1
    Iteriranje kroz kolekciju pomocu naredbe foreach: 3 2 1
    S=6, N=3, avg=2, prvi=3, poslednji=1, min=1, max=3
    Neparni elementi: 3 1
    ------------------
    Tip kolekcije: System.Collections.Generic.Queue`1[System.Int32]
    Iteriranje kroz kolekciju pomocu enumeratora: 1 2 3
    Iteriranje kroz kolekciju pomocu naredbe foreach: 1 2 3
    S=6, N=3, avg=2, prvi=1, poslednji=3, min=1, max=3
    Neparni elementi: 1 3
    ------------------
    Tip kolekcije: System.Collections.Generic.SortedSet`1[System.Int32]
    Iteriranje kroz kolekciju pomocu enumeratora: 1 2 3
    Iteriranje kroz kolekciju pomocu naredbe foreach: 1 2 3
    S=6, N=3, avg=2, prvi=1, poslednji=3, min=1, max=3
    Neparni elementi: 1 3
    ------------------
    Tip kolekcije: System.Collections.Generic.List`1[System.Int32]
    Iteriranje kroz kolekciju pomocu enumeratora: 1 2 3
    Iteriranje kroz kolekciju pomocu naredbe foreach: 1 2 3
    S=6, N=3, avg=2, prvi=1, poslednji=3, min=1, max=3
    Neparni elementi: 1 3
    ------------------
    Tip kolekcije: System.Int32[]
    Iteriranje kroz kolekciju pomocu enumeratora: 1 2 3
    Iteriranje kroz kolekciju pomocu naredbe foreach: 1 2 3
    S=6, N=3, avg=2, prvi=1, poslednji=3, min=1, max=3
    Neparni elementi: 1 3
    ------------------

Због овако богате подршке интерфејсу ``IEnumerable``, напомињемо да и класе које ми пишемо могу да 
се користе на овај начин, а ради тога је довољно да имплементирају интерфејс ``IEnumerable``. У 
наставку дајемо две различите дораде претходног програма. У обе дораде је дефинисана класа ``Fib``, 
која имплементира интерфејс ``IEnumerable<int>``. Захваљујући томе, ова класа може да се користи 
на исти начин као и библиотечке класе из основног програма, што је овим у дорадама и демонстрирано. 
Интересантно је да, иако се класа ``Fib`` користи као колекција Фибоначијевих бројева, она у себи 
не садржи стварно колекцију тих бројева, већ сваки број израчунава тек када је то потребно, тј. 
када се итерирањем стигне до њега. 

Различите имплементације класе ``Fib``, заједно са програмом у коме се она користи, можете да 
видите кликом на одговарајуће дугме испод.

.. reveal:: dugme_prva_implementacija
    :showtitle: Класа Fib са енумераторском класом
    :hidetitle: Сакриј имплементацију са енумераторском класом

    **Класа Fib са енумераторском класом**
    
    .. activecode:: ienumerable_fib_enumerator_class
        :passivecode: true
        :includesrc: src/primeri/ienumerable_fib_enumerator_class.cs

.. reveal:: dugme_druga_implementacija
    :showtitle: Класа Fib са наредбом yield
    :hidetitle: Сакриј имплементацију са наредбом yield

    **Класа Fib са наредбом yield**
    
    .. activecode:: ienumerable_fib_enumerator_yield
        :passivecode: true
        :includesrc: src/primeri/ienumerable_fib_enumerator_yield.cs


.. comment

    IComparable, IDisposable, 
    IEnumerable, ISerializable, ICloneable, ICollection
    IList, IStructuralComparable, IStructuralEquatable
    
