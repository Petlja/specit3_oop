Употреба сопствених интерфејса
==============================

Писање интерфејса
-----------------

Писање интерфејса је једноставније од писања апстрактне класе. Као прво, није потребно писати реч 
``abstract`` ни испред имена интерфејса, ни испред имена метода, јер интерфејс је апстрактан по 
дефиницији. Такође, подразумева се да су методи јавни ако се не наведе другачије, па не треба писати 
ни реч ``public`` испред имена метода. У класи која имплементира интерфејс није потребно писати реч 
``override`` испред имена метода, јер ако класа није апстрактна она мора да имплементира методе 
декларисане у интерфејсу. 

Погледајмо ово на следећем примеру.

Пример - настави низ
^^^^^^^^^^^^^^^^^^^^

Програм који је пред вама садржи веома једноставан интерфејс ``IClanPoClan``, који декларише само 
метод ``long Sledeci()``. Дате су четири класе које на различите начине имплементирају овај 
интерфејс. Свака од тих класа даје редом елементе неког целобројног низа, при чему се елементи 
ређају по неком правилу (сваки позив метода ``Sledeci`` даје следећи члан). Задатак корисника је 
да погоди следећи члан низа. Покрените и испробајте програм. 

.. activecode:: interfejs_nastavi_niz
    :passivecode: true
    :includesrc: src/primeri/interfejs_nastavi_niz.cs
    
Видимо да је након формирања објекта ``niz`` руковање тим објектом сасвим једноставно, јер се 
користи само метод ``Sledeci()`` из интерфејса, за који знамо да је имплементиран (а ништа друго 
не знамо о објекту ``niz``, нити је потребно). 

Ово је још један пример генерализације, где смо једноставну заједничку функционалност неколико 
класа овај пут издвојили у заједнички интерфејс, уместо апстрактне базне класе. 

Овакав програм није погодан за тестирање класа, јер се у њему користи генератор случајних бројева, 
па не знамо када је која класа инстанцирана, а док се свака класа инстанцира бар по једном, може 
да прође произвољно мнгоо времена. Зато је за тестирање згодније употребити кôд попут овог:

.. code-block:: csharp

    IClanPoClan[] nizovi = new IClanPoClan[] 
    {
        new AritmetickiNiz(10, 20),
        new GeometrijskiNiz(3, 2),
        new FibonacijevNiz(1, 1),
        new NaizmenicniNiz(1, 3, 100, -2)
    };

    foreach (var niz in nizovi)
    {
        for (int i = 0; i < 10; i++)
            Console.Write("{0,7}", niz.Sledeci());

        Console.WriteLine();
    }

На овај начин брзо и јасно видимо да ли свака класа враћа баш оне елементе које очекујемо. 
