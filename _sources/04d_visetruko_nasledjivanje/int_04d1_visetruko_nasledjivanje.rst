Интерфејси
==========

У овој лекцији:

- Зашто су нам потребни интерфејси (проблем вишеструког наслеђивања)
- Шта је интерфејс и како се разликује од апстрактне класе
- Примери интерфејса из .Net библиотеке
- Креирање и имплементирање сопствених интерфејса

.. comment

    РЕДОСЛЕД

    - проблем  "дијамант" наслеђивања
    
    
    Појам интерфејса
    ----------------
    
    како интерфејс отклања проблем (и даље имам све што нам треба, а немамо више проблем)

    - разлике између интерфејса и апстрактне класе:

        - интерфејс нема имплементиране методе (само најављене, тј. декларисане методе)
        - због тога класа може да наследи више интерфејса (нема могућности конфликта), 
          али само једну класу (апстрактну или не)


    Примери интерфејса из .Net библиотеке
    -------------------------------------

    Интерфејс IComparable
    ^^^^^^^^^^^^^^^^^^^^^

    Да бисмо над низом неких објеката могли да користимо метод ``Array.Sort``, потребно је да буде 
    дефинисано поређење тих објеката, тј. да се зна који објекат треба да претходи другом објекту у 
    сортираном поретку.

    ...

    .. code-block:: csharp

        public class Razlomak : IComparable
        {
            ...
            
            public int CompareTo(object obj)
            {
                Razlomak r = obj as Razlomak;
                return a * r.b - r.a * b;
            }
        }
        
        static void Main(string[] args) { 
            Razlomak[] r ...
            Array.Sort(r);
        }


    Интерфејс IEnumerable
    ^^^^^^^^^^^^^^^^^^^^^

    Наредба ``foreach`` нам омогућава да прођемо кроз колекцију објеката (или променљивих) а да не 
    користимо ``for`` са бројачком променљивом. Петља ``foreach`` се сматра удобнијом и безбеднијом, 
    јер се спречава могућност приступања непостојећем елементу колекције (када је индекс ван граница). 
    Ову врсту петље сте до сада вероватно користили над низовима, листама, скуповима и сличним 
    колекцијама дефинисаним у стандардној библиотеци. 
    
    Да бисмо могли да користимо петљу ``foreach`` над колекцијом коју сами дефинишемо, довољно је да 
    та колекција имплементира интерфејс IEnumerable.
    
    ...

    
    .. code-block:: csharp

        public class SparseArray : IEnumerable<double>
        { ... }
        
        SparseArray x = new SparseArray();
        foreach (var v in x)
            Console.WriteLine(v);
